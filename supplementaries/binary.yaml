bioconductor:
  intersect:
    basic: |
      pairs = findOverlapPairs(gr2, gr1, ignore.strand = FALSE)
      result = pintersect(pairs, ignore.strand = FALSE)
      result = result[mcols(result)$hit == TRUE]
  overlap:
    basic: |
      result = findOverlapPairs(gr2, gr1, ignore.strand = FALSE)
      result = first(result)
  nearest:
    basic: |
      result = distanceToNearest(gr1, gr2, ignore.strand = FALSE, select="arbitrary")
    full: |
      subject = as.data.frame(gr1[subjectHits(result)])
      colnames(subject) = paste0(colnames(subject), "_b")
      query = as.data.frame(gr2[queryHits(result)])
      df = merge(subject, query, by=0)
      df = df[, -1]
      df = merge(df, mcols(result)$distance, by=0)
      df = df[, -1]
      result = makeGRangesFromDataFrame(df, keep.extra.columns=TRUE)
  nearest_nonoverlapping:
    basic: |
      fun <- function(x) {min(x) == x & !duplicated(x)}

      result <- union(
      # there is a bug in this method (suggested by the developers), so does not work with returning only single query
      # must use all. see https://support.bioconductor.org/p/110506/
      precede(gr1, gr2, select="all"),
      follow(gr1, gr2, select="all")
      )
      ## minimum distance by query
    full: |
      distance <- distance(gr1[queryHits(result)], gr2[subjectHits(result)])
      lst <- splitAsList(distance, queryHits(result))
      keep <- unsplit(fun(lst), queryHits(result))
      ## clean-up
      mcols(result)$distance <- distance
      result = result[keep]
  set_intersect:
    basic: |
      result = intersect(gr2, gr1)
  set_union:
    basic: |
      result = union(gr1, gr2)
  join:
    basic: |
      result <- findOverlapPairs(gr1, gr2, ignore.strand = TRUE)
    code: |
      df1 = as.data.frame(first(result))
      df2 = as.data.frame(second(result))
      colnames(df2) = paste0(colnames(df2), "_b")
      df = merge(df1, df2, by=0)
      result = makeGRangesFromDataFrame(df, keep.extra.columns=TRUE)
  subtract:
    basic: |
      result = psetdiff(gr1, gr2, ignore.strand=FALSE)

pybedtools:
  intersect:
    result = pb1.intersect(pb2, s=True)
  overlap:
    result = pb1.intersect(pb2, s=True, wa=True)
  nearest:
    result = pb1.sort().closest(pb2.sort(), s=True)
  nearest_nonoverlapping:
    result = pb1.sort().closest(pb2.sort(), s=True, io=True)
  set_intersect: |
    # the first flag is needed to keep the sixth columns
    sc = pb1.sort().merge(s=True, c=[4, 5, 6], o="first")
    sb = pb2.sort().merge(s=True, c=[4, 5, 6], o="first")
    result = sc.intersect(sb, s=True)
  set_union: |
    # the first flag is needed to keep the sixth columns
    sc = pb1.sort().merge(s=True, c=[4, 5, 6], o="first")
    sb = pb2.sort().merge(s=True, c=[4, 5, 6], o="first")
    catted = sc.cat(sb, s=True, c=[4, 5, 6], o="first").sort()
    result = catted.merge(s=True, c=[4, 5, 6], o="first")
  join:
    result = pb1.intersect(pb2, wao=True)
  subtract:
    result = pb1.subtract(pb2)
  jaccard:
    result = pb1.sort().jaccard(pb2.sort())


pyranges:
  intersect:
    result = gr.intersect(gr2, strandedness="same")
  overlap:
    result = gr.overlap(gr2, strandedness="same")
  nearest:
    result = gr.nearest(gr2, strandedness="same")
  nearest_nonoverlapping:
    result = gr.nearest(gr2, strandedness="same", overlap=False)
  set_intersect: |
    result = gr.set_intersect(gr2, strandedness="same")
  set_union: |
    result = gr.set_union(gr2, strandedness="same")
  join: |
    result = gr.join(gr2, strandedness="same")
  subtract: |
    result = gr.subtract(gr2, strandedness="same")
  jaccard: |
    result = gr.jaccard(gr2)
